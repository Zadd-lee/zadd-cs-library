---
created: 2026-01-30T19:00
updated: 2026-01-30T19:26
---
입력 크기에 따라 알고리즘이 해결하는 데 필요한 시간(연산 횟수)과 공간(메모리)등의 자원을 분석하여 알고리즘의 효율성을 평가하는 분야

# 공간 복잡도
알고리즘이 문제를 해결하는 데 필요한 메모리 공간의 양을 측정
# 시간 복잡도
입력 크기(n)에 따라 알고리즘을 수행하는 데 걸리는 단계의 수(시간)
시간 복잡도는 낮으면 낮을 수록 좋다

## Big-O notation 
최악의 경우 시간 복잡도를 표현

어떤 프로그램의 연산 횟수가 f(x)라고 할때 함수의 초고차항을 남기고 차수를 지워 O(…)와 같이 표기하면 된다

코딩 테스트 문제에는 제한 시간이 있으므로 문제를 분석한 후에 빅오 표기법을 활용해서 해당 알고리즘을 적용했을 때 제한 시간 내에 출력값이 나올 수 있을지 확인해볼 수 있다


**연산 횟수는 1,000~3,000만 정도로 고려해서 시간 복잡도를 생각하면 됩니다**

| 시간 복잡도     | 최대 연산 횟수     |
| ---------- | ------------ |
| O($N!$)    | 10           |
| O($2^{N}$) | 20~25        |
| O($N^{3}$) | 200~300      |
| O($N^{2}$) | 3,000~5,000  |
| O($NlogN$) | 100만         |
| O($N$)     | 1,000~2,000만 |
| O($logN$)  | 10억          |


### O(1) - 상수
입력 데이터 크기에 상관 없이 언제나 일정 시간이 걸리는 알고리즘
### O($N$) - 선형
입력 데이터의 크기에 비례해서 처리 시간이 걸리는 알고리즘
n이 1번 늘어날때마다 처리 시간이 1 증가

### O($N^{2}$)
입력 데이터 n만큼 반복하는데, 그 안에서 n만큼 또 반복할 때
```java
for(int i=0;i<n.length;i++){
	for(int j=0;j<n.length;j++){
		System.out.println(i+j);
	}
}
```

### O($nm$)
```java
for(int i=0;i<n.length;i++){
	for(int j=0;j<m.length;j++){
		System.out.println(i+j);
	}
}
```
### O($N^{3}$)
```java
for(int i=0;i<n.length;i++){
	for(int j=0;j<m.length;j++){
		for(int k=0;k<m.length;k++){
			System.out.println(i+j+k);
		}
	}
}
```

### O($2^{N}$)
대표적인 알고리즘 : 피보나치 수열
``` JAVA
public int fibo(int n){
if(n<=1) return n;
else return fib(n-1)+fib(n-2);
}
```

### O($logN$)
대표적인 알고리즘 : 이진 탐색